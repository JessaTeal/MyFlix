{"dependencies":[{"name":"lodash","loc":{"line":4,"column":18}},{"name":"../base","loc":{"line":5,"column":23}},{"name":"../context","loc":{"line":6,"column":26}},{"name":"../select-fields","loc":{"line":7,"column":32}},{"name":"../validation-result","loc":{"line":8,"column":36}}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextRunnerImpl = exports.ResultWithContext = void 0;\nconst _ = require(\"lodash\");\nconst base_1 = require(\"../base\");\nconst context_1 = require(\"../context\");\nconst select_fields_1 = require(\"../select-fields\");\nconst validation_result_1 = require(\"../validation-result\");\nclass ResultWithContext extends validation_result_1.Result {\n    constructor(context) {\n        super(error => error, context.errors);\n        this.context = context;\n    }\n}\nexports.ResultWithContext = ResultWithContext;\nclass ContextRunnerImpl {\n    constructor(builderOrContext, selectFields = select_fields_1.selectFields) {\n        this.builderOrContext = builderOrContext;\n        this.selectFields = selectFields;\n    }\n    async run(req, options = {}) {\n        const context = this.builderOrContext instanceof context_1.Context\n            ? this.builderOrContext\n            : this.builderOrContext.build();\n        const instances = this.selectFields(req, context.fields, context.locations);\n        context.addFieldInstances(instances);\n        const haltedInstances = new Set();\n        for (const contextItem of context.stack) {\n            const promises = context.getData({ requiredOnly: true }).map(async (instance) => {\n                const { location, path } = instance;\n                const instanceKey = `${location}:${path}`;\n                if (haltedInstances.has(instanceKey)) {\n                    return;\n                }\n                try {\n                    await contextItem.run(context, instance.value, {\n                        req,\n                        location,\n                        path,\n                    });\n                    // An instance is mutable, so if an item changed its value, there's no need to call getData again\n                    const newValue = instance.value;\n                    // Checks whether the value changed.\n                    // Avoids e.g. undefined values being set on the request if it didn't have the key initially.\n                    const reqValue = path !== '' ? _.get(req[location], path) : req[location];\n                    if (!options.dryRun && reqValue !== instance.value) {\n                        path !== '' ? _.set(req[location], path, newValue) : _.set(req, location, newValue);\n                    }\n                }\n                catch (e) {\n                    if (e instanceof base_1.ValidationHalt) {\n                        haltedInstances.add(instanceKey);\n                        return;\n                    }\n                    throw e;\n                }\n            });\n            await Promise.all(promises);\n        }\n        if (!options.dryRun) {\n            const internalReq = req;\n            internalReq[base_1.contextsKey] = (internalReq[base_1.contextsKey] || []).concat(context);\n        }\n        return new ResultWithContext(context);\n    }\n}\nexports.ContextRunnerImpl = ContextRunnerImpl;\n"},"hash":"c362d82d3f3824e88d76c3b1824cdcfb"}